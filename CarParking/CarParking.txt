import java.time.LocalDateTime;
import java.time.Duration;
import java.util.*;

enum VehicleType {
    CAR(2.0),
    MOTORCYCLE(1.0),
    TRUCK(3.5),
    BUS(5.0);
    
    private final double hourlyRate;
    
    VehicleType(double hourlyRate) {
        this.hourlyRate = hourlyRate;
    }
    
    public double getHourlyRate() {
        return hourlyRate;
    }
}

class Vehicle {
    private String licensePlate;
    private VehicleType type;
    
    public Vehicle(String licensePlate, VehicleType type) {
        this.licensePlate = licensePlate;
        this.type = type;
    }

    public String getLicensePlate() {
        return licensePlate;
    }
    
    public VehicleType getType() {
        return type;
    }
}

class ParkingSpot {
    private String id;
    private boolean occupied;
    private VehicleType allowedType;

    public ParkingSpot(String id, VehicleType allowedType) {
        this.id = id;
        this.occupied = false;
        this.allowedType = allowedType;
    }
    
    public boolean isOccupied() {
        return occupied;
    }

    public void free() {
        this.occupied = false;
    }

    public void occupy() {
        this.occupied = true;
    }

    public String getId() {
        return this.id;
    }
    
    public VehicleType getAllowedType() {
        return allowedType;
    }
    
    public boolean canAccommodate(VehicleType vehicleType) {
        return allowedType == vehicleType || 
               (allowedType == VehicleType.TRUCK && vehicleType == VehicleType.CAR) ||
               (allowedType == VehicleType.CAR && vehicleType == VehicleType.MOTORCYCLE);
    }
}

class ParkingTicket {
    private String ticketId;
    private Vehicle vehicle;
    private ParkingSpot spot;
    private LocalDateTime inTime;
    private LocalDateTime outTime;

    public ParkingTicket(Vehicle vehicle, ParkingSpot spot) {
        this.ticketId = UUID.randomUUID().toString();
        this.vehicle = vehicle;
        this.spot = spot;
        this.inTime = LocalDateTime.now();
    }

    public String getTicketId() {
        return ticketId;
    }

    public ParkingSpot getSpot() {
        return spot;
    }
    
    public Vehicle getVehicle() {
        return vehicle;
    }

    public void markExit() {
        outTime = LocalDateTime.now();
    }

    public long getDurationMinutes() {
        if (outTime == null) {
            return Duration.between(inTime, LocalDateTime.now()).toMinutes();
        }
        return Duration.between(inTime, outTime).toMinutes();
    }
    
    public double calculateCost() {
        double hours = getDurationMinutes() / 60.0;
        double minimumCharge = Math.max(hours, 1.0); // Minimum 1 hour charge
        return minimumCharge * vehicle.getType().getHourlyRate();
    }
    
    public LocalDateTime getInTime() {
        return inTime;
    }
    
    public LocalDateTime getOutTime() {
        return outTime;
    }
}

class ParkingLotException extends Exception {
    public ParkingLotException(String message) {
        super(message);
    }
}

public class ParkingLot {
    private List<ParkingSpot> spots;
    private Map<String, ParkingTicket> tickets;
    private Map<VehicleType, Integer> capacityByType;

    public ParkingLot() {
        spots = new ArrayList<>();
        tickets = new HashMap<>();
        capacityByType = new HashMap<>();
        initializeDefaultSpots();
    }
    
    private void initializeDefaultSpots() {
        // Create a mixed parking lot
        addSpots(VehicleType.CAR, 10);
        addSpots(VehicleType.MOTORCYCLE, 5);
        addSpots(VehicleType.TRUCK, 3);
        addSpots(VehicleType.BUS, 2);
    }
    
    public void addSpots(VehicleType type, int count) {
        int currentCount = capacityByType.getOrDefault(type, 0);
        for (int i = 0; i < count; i++) {
            String spotId = type.name() + "-" + (currentCount + i + 1);
            spots.add(new ParkingSpot(spotId, type));
        }
        capacityByType.put(type, currentCount + count);
    }

    // Park a vehicle in the first available compatible spot
    public ParkingTicket park(Vehicle vehicle) throws ParkingLotException {
        if (vehicle == null) {
            throw new ParkingLotException("Vehicle cannot be null");
        }
        
        for (ParkingSpot spot : spots) {
            if (!spot.isOccupied() && spot.canAccommodate(vehicle.getType())) {
                spot.occupy();
                ParkingTicket ticket = new ParkingTicket(vehicle, spot);
                tickets.put(ticket.getTicketId(), ticket);
                System.out.println("Vehicle " + vehicle.getLicensePlate() + 
                                 " parked at " + spot.getId());
                return ticket;
            }
        }
        throw new ParkingLotException("No available spots for vehicle type: " + 
                                    vehicle.getType());
    }

    // Unpark using ticket ID
    public double unpark(String ticketId) throws ParkingLotException {
        ParkingTicket ticket = tickets.get(ticketId);
        if (ticket == null) {
            throw new ParkingLotException("Invalid ticket ID: " + ticketId);
        }
        
        ticket.markExit();
        ParkingSpot spot = ticket.getSpot();
        spot.free();
        
        double cost = ticket.calculateCost();
        long duration = ticket.getDurationMinutes();
        
        tickets.remove(ticketId);
        
        System.out.println("Vehicle " + ticket.getVehicle().getLicensePlate() + 
                         " unparked from " + spot.getId() + 
                         "; Duration: " + duration + " mins" +
                         "; Cost: $" + String.format("%.2f", cost));
        
        return cost;
    }

    public int getAvailableCount() {
        int count = 0;
        for (ParkingSpot spot : spots) {
            if (!spot.isOccupied()) count++;
        }
        return count;
    }
    
    public int getAvailableCount(VehicleType type) {
        int count = 0;
        for (ParkingSpot spot : spots) {
            if (!spot.isOccupied() && spot.canAccommodate(type)) {
                count++;
            }
        }
        return count;
    }
    
    public Map<VehicleType, Integer> getAvailabilityByType() {
        Map<VehicleType, Integer> availability = new HashMap<>();
        for (VehicleType type : VehicleType.values()) {
            availability.put(type, getAvailableCount(type));
        }
        return availability;
    }
    
    public List<ParkingTicket> getCurrentTickets() {
        return new ArrayList<>(tickets.values());
    }
    
    public double getTotalRevenue() {
        double total = 0.0;
        for (ParkingTicket ticket : tickets.values()) {
            if (ticket.getOutTime() != null) {
                total += ticket.calculateCost();
            }
        }
        return total;
    }

    public static void main(String[] args) {
        try {
            ParkingLot lot = new ParkingLot();
            
            // Test different vehicle types
            Vehicle car1 = new Vehicle("KA-01-1234", VehicleType.CAR);
            Vehicle motorcycle1 = new Vehicle("KA-02-5678", VehicleType.MOTORCYCLE);
            Vehicle truck1 = new Vehicle("KA-03-9012", VehicleType.TRUCK);
            
            System.out.println("=== Parking Lot Management System ===");
            System.out.println("Initial availability: " + lot.getAvailabilityByType());
            
            // Park vehicles
            ParkingTicket t1 = lot.park(car1);
            ParkingTicket t2 = lot.park(motorcycle1);
            ParkingTicket t3 = lot.park(truck1);
            
            System.out.println("\nAfter parking:");
            System.out.println("Available spots: " + lot.getAvailableCount());
            System.out.println("Availability by type: " + lot.getAvailabilityByType());
            
            // Simulate some parking time
            Thread.sleep(2000);
            
            // Unpark vehicles
            System.out.println("\n=== Checkout Process ===");
            double cost1 = lot.unpark(t1.getTicketId());
            double cost2 = lot.unpark(t2.getTicketId());
            double cost3 = lot.unpark(t3.getTicketId());
            
            System.out.println("\nFinal availability: " + lot.getAvailabilityByType());
            System.out.println("Total revenue: $" + String.format("%.2f", 
                             cost1 + cost2 + cost3));
            
        } catch (ParkingLotException | InterruptedException e) {
            System.err.println("Error: " + e.getMessage());
        }
    }
}

	